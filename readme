							On a UNIX Environment 
0*-remove the UserProxy and all its Changes and remove feign client from the 
1- Add the dependency of RabbitMQ in Parent POM.xml {sping boot starter AMQP} without version
2-Create a package--> rabbitmq
	
//this class signature should match the domain class signature in userauthentication service
		public class UserDTO{
		String email;
		String password;
		create G&C DC
			} 
3-create a configuration class inside a config package already there 
	
	@Configuration
	public class MessageConfiguration{
	
	private String exchangeName="user_exchange";
	private String registerQueue="user_queue";
	
	@Bean //import from amqp.core
	public DirectExchange directExchange(){
		return new DirectExchange(exchangeName);
	}
	
	@Bean
	public Queue registerQueue(){
		return new Queue(registerQueue);//it takes two parameter string and boolean durable
	}//end of function


	//to convert the object data to binary format so that RabbitMQ will accept it, so we are using the library Jackson2JsonMessageConvertor
	@Bean 
	Jackson2JsonMessageConvertor producerJacksonConvertor(){return new Jackson2JsonMessageConvertor();}

	@Bean                    //import from connectionfactory from amqp.core
	RabbitTemplate rabbitTemplate(final ConnectionFactory connectionFactory ){
		RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
		//the message that comes to RabbitTemplate is to be converted 
		rabbitTemplate.setMessageConvertor(producerJacksonConvertor());	
	}//end of function


	//create a Binding Bean
	@Bean
	public Binding bindingUser(Queue registerQueue, DirectExchange exchange){
		//binding builder from amqp.core 
		//with() is for defining routing key whereas the user_routing is the routing key and during consuming we need to use this routing key
		//binding Queue with exchange
	return BindingBuilder.bind(registerQueue()).to(exchange).with("user_routing");
	} 
	
	
	}//end of class


4-create a class  {PRODUCER SERVICE}  that will act as a producer inside a config package 
	
	
	@Component
	public class Producer{
	
	private RabbitTemplate rabbitTemplate;
	private DirectExchange exchange; 
	

	@Autowired
	public Producer(RabbitTemplate rabbitTemplate, DirectExchange exchange){this.exchange=exchange;this.rabbitTemplate=rabbitTemplate;}
	
	
	public void sendMessageToRabbitMq(UserDTO userDTO){
		//covert the (exchange,routing key,object) 
	rabbitTemplate.convertAndSend(exchange.getName(),"user_routing",userDTO);
	
	}//end of function
		
	}//classs end

 
6-At serviceImpl of userMovieservice

	autowired it with constructor injection or 
	private Producer producer
	
	@Override
	public User registerUser(User user){
		//create an object of DTO class 
		UserDTO userDTO = new UserDTO();
		userDTO.setEmail(user.getEmail());
		userDTO.setPassword(user.getPassword);
		
		if(){.....leave it as it is.....}
		
		producer.sendMessageToRabbitMq(userDTO);//sending the data to the rabbitMQ server

	}

	

7-create a package rabbitmq inside {CONSUMER SERVICE} userauthentication as rabbitmq and create a class
	
	public class UserDTO{
		String email;
		String password;
		create G&C DC
			} 

8-create a package config

	@Configuration
	public class MessageConfiguration{
	
	@Bean
	public Jackson2JsonMessageConvertor jsonMessageConvertor(){return new Jackson2JsonMessageConvertor(); }	

	}//end of class

9-create a Consumer class in Config
	
	@Component
	public class Consumer{
		
	//calling the method from userAuthentication serviceImpl for we will use the DTO class for Service 	
	@Autowired
	private UserServiceImpl userService;

	//queue name what is defined in configuration of movieService
	@RabbitListener(queues="user_queue")
	public void getUserDtoFromRabbitMq(UserDTO userDTO)throws UserAlreadyExistException{
	
	User user =new User();
	user.setEmail(userDTO.getEmail());
	user.setPassword(userDTO.getPassword());
	userService.saveUser(user)
	}//end of the function

	}//end of the class 


10- If Compatibility error pops up
add property in  application.properties of userAuthenticationService(for this error pops for userauthentication services)

	spring.cloud.compatibility-verifier.enabled=false

11-in docker-compose.yml
	
	rabbitmq:
	     image: rabbitmq:3.8.23-management
	     ports:
	         - 5672:5672
	         - 15672:15672
	     
=====================================================================================================================================
								COMMANDS TO RUN ON TERMINAL
-remove all runnning container and images if possible 
-enable and initialize rabbitmq container
 	sudo docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.8.23-management
-//stop mongod and mysql services and mvn install
	sudo service mongod stop
	sudo service mysql stop

//build and up all the containers 
-	sudo docker-compose up --build
//check the containers
-	sudo docker ps -a

-check the postman and have your play and check MySQL workbench and MongoDB Compass and check the data feeds and token generation 


=====================================================================================================================================
									BACKEND DONE Without Connecting it To FrontEnd 





